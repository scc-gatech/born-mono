.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "net::koko::src::our::seplib-6.1::docs::pod::seplib_base::copy_history 3"
.TH net::koko::src::our::seplib-6.1::docs::pod::seplib_base::copy_history 3 "Thu Feb 12 16:08:08 2004" "6.0" "SEPlib Manual Pages"
.SH "NAME"
auxin, auxout, auxinout, auxscr,auxsockout,copy_history \- returns I/O pointer 
to auxiliary data file
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        From C:
\&        #include <seplib.h>
.Ve
.PP
.Vb 8
\&        FILE *auxin(tag)
\&        FILE *auxtmp(tag);
\&        FILE *auxout(tag)
\&        FILE *auxinout(tag)
\&        FILE *auxsockout(tag)
\&        FILE *auxscr(tag)
\&        void copy_history( intag, outtag )
\&        char *tag, *intag, *outtag;
.Ve
.PP
.Vb 1
\&        From Fortran:
.Ve
.PP
.Vb 7
\&        integer auxin(tag)
\&        integer auxout(tag)
\&        integer auxinout(tag)
\&        integer auxsockout(tag)
\&        integer auxscr(tag)
\&        integer auxtmp(tag)
\&        integer copy_history(intag,outtag)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These routines open an auxillary seplib dataset for input, output, or
both. For historical reasons they return a stream pointer 
(or a file descriptor for Fortran users).  These return values should not
be used for I/O. Always use the tag name to read and write data. The
return values should only be used to check for errors.
.PP
For \fIauxin()\fR the location of this data is determined by a line \*(L"in=filename\*(R" 
in the auxiliary input history.  The history is in turn located according the
following priorities:
Look for 'tag=history' on the command line.
Look for 'tag=history' on standard input.
Look for the file `tag' in the current directory.
.PP
For \fIauxout()\fR, an output history is created and
initialized as necessary. The default name `tag' of this
output history may be overrrided by specifying `tag=history'
on the command line. If the output
history already exists it will be overwritten.
The location of the data file is constructed
automatically following rules similar to those used by
\&\fIoutput()\fR. If the file exists it will be truncated to zero length
before starting output.
.PP
For \fIauxinout()\fR, the history file will be searched for using the same
rules as auxin and appended to if it exists.
If the history already exists, the data file it points at will be
reused. If you wish to append to the end of that file you should
seek to the end before writing.  If the history file doesn't exist the 
history file and data file will be created as for auxout.
The call to \fIauxinout()\fR must be the first use of the tag in your program.
Any other call will implicity open the dataset as either an input or
output dataset.
.PP
\&\fIcopy_history()\fR is used to copy the input history from the stream
defined by tagin to the stream defined by tagout. 
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 3
\&        A binary file "elevations" has been generated for a 
\&        seismic section. The history, say Helev, describing it 
\&        would contain
.Ve
.PP
.Vb 1
\&                in="elevations"
.Ve
.PP
.Vb 1
\&                ne=120 units=feet datum=250
.Ve
.PP
.Vb 1
\&        A program written to use these elevations would be invoked
.Ve
.PP
.Vb 1
\&                <Hin Prog elev=Helev >Hout
.Ve
.PP
.Vb 1
\&        and the source for Prog might contain code such as
.Ve
.PP
.Vb 1
\&                auxpar("ne","d",&ne,"elev");
.Ve
.PP
.Vb 1
\&                auxpar("esize","d",&esize,"elev");
.Ve
.PP
.Vb 1
\&                auxpar("units","s",units,"elev");
.Ve
.PP
.Vb 1
\&                auxpar("datum","f",&datum,"elev");
.Ve
.PP
.Vb 1
\&                sreed("elev",elevations,ne*esize)
.Ve
.PP
.Vb 1
\&                for(i=0; i<ne; ++i) elevations[i] -= datum;
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.Vb 5
\&        Calls to auxin()/auxout()/auxinout()/auxsockout()/auxscr() from C return 
\&        NULL if there is no auxiliary history or data whilst
\&        the fortran routine returns -1 in the same situation.
\&        Other errors will cause program termination with a
\&        suitable message.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 2
\&        L<auxclose>, L<auxpar>, L<auxputch>, input, L<sreed>, L<srite>, 
\&        L<sseek>
.Ve
.SH "BUGS"
.IX Header "BUGS"
.Vb 2
\&        Don't forget to declare auxin an integer in Fortran 
\&        and Ratfor programs.
.Ve
.SH "KEYWORDS"
.IX Header "KEYWORDS"
auxillary dataset input output
.SH "LIBRARY"
.IX Header "LIBRARY"
\&\fBsep\fR
