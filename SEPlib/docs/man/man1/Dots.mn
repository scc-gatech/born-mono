.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DOTS 1"
.TH DOTS 1 "Thu Feb 12 16:08:08 2004" "6.0" "SEPlib Manual Pages"
.SH "NAME"
Dots \- plots data as 'lollipops'
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
<in.H  Dots  [options]  | Tube
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Plots a data plane, like 'Wiggle,' but lollipops on strings.
Adapts default data format to values of n1,n2.
Can put a separate label on each trace.  (see labels=)
Data area fills screen when title= label1= labels= 
are undefined.
.SH "COMMENTS"
.IX Header "COMMENTS"
A program somewhat like Wiggle, but better in some ways because
it tries to be smarter. The output style depends on the input
n1 and n2. For loosely packed traces with only a few data 
points Dots plots the data as lollipops on strings, showing
each data point clearly. There are also options for separately
labeling each trace, omitting dead traces, making bar graphs,
etc. As n1 and n2 increase Dots by default simplifies the
output and eventually behaves almost the same as Wiggle.
Unfortunately Dots does not use the axis drawing and plotting
routines shared by Wiggle, Contour, Graph and Ta2vplot, and
so Dots' options and ouput plot size, position, and axes 
are currently incompatible with those for other plot programs.
.SH "INPUT PARAMETERS"
.IX Header "INPUT PARAMETERS"
.IP "seemean-int" 4
.IX Item "seemean-int"
.Vb 2
\&      [1] draw axes lines (=0 means don't)
\&      0  default not to when n2>30 to avoid clutter
.Ve
.IP "strings-int" 4
.IX Item "strings-int"
.Vb 2
\&      [1]  draw strings from axis to balloons
\&      0  default not to when n1>400 since too slow
.Ve
.IP "wantaxis-int" 4
.IX Item "wantaxis-int"
.Vb 1
\&      [1]  draw  bottom axis
.Ve
.IP "dots   \-int" 4
.IX Item "dots   -int"
.Vb 3
\&      [1] draw the balloons
\&      0 default not to when n1>130 since dots are small
\&      2 draw dots only where signal is not zero.
.Ve
.IP "corners-int" 4
.IX Item "corners-int"
.Vb 1
\&      [6] corners on area-filled polygon dots.
.Ve
.IP "connect-int" 4
.IX Item "connect-int"
.Vb 5
\&      1 connect the dots on diagonal lines.
\&      2 connect the dots as a bar graph.
\&      3 bar graph with only horizontal bars.
\&      4 connect dots only where signal is not zero.
\&      0 don't connect adjacent values in any way.
.Ve
.IP "clip  \-float" 4
.IX Item "clip  -float"
.Vb 1
\&      your chosen clip value.
.Ve
.IP "overlap-float" 4
.IX Item "overlap-float"
.Vb 1
\&      [.90]  trace overlap at clip value
.Ve
.IP "gaineach \- int" 4
.IX Item "gaineach - int"
.Vb 1
\&      1 gain each trace independently (=0 gain all together)
.Ve
.IP "constsep \- int" 4
.IX Item "constsep - int"
.Vb 2
\&      0 trace separations depend on both max and min.
\&      1 trace separation depends on max abs value.
.Ve
.IP "seedead \-  int" 4
.IX Item "seedead -  int"
.Vb 1
\&      0 plot dead traces as zero traces or don't plot them.
.Ve
.IP "silk    \-  int" 4
.IX Item "silk    -  int"
.Vb 2
\&      [0] wiggle traces
\&      1 silk screen variable area(see SEP CD-ROM platter plot)
.Ve
.IP "title,label1\- char*" 4
.IX Item "title,label1- char*"
.Vb 1
\&      usual meaning
.Ve
.IP "labels \- char*" 4
.IX Item "labels - char*"
.Vb 1
\&      trace labels, i.e. labels=in:filt:out
.Ve
.IP "labelsz \-int" 4
.IX Item "labelsz -int"
.Vb 1
\&      [8] label size
.Ve
.IP "yreverse \- int" 4
.IX Item "yreverse - int"
.Vb 1
\&      [0] =1, reverse order of channels.
.Ve
.IP "transp \- int" 4
.IX Item "transp - int"
.Vb 1
\&      [0] flip axes.   (Buggy for title and label1).
.Ve
.IP "xxscale \- float" 4
.IX Item "xxscale - float"
.Vb 1
\&      [1.] <1. for smaller plots, narrow plots, etc.
.Ve
.IP "yyscale \- float" 4
.IX Item "yyscale - float"
.Vb 1
\&      [1.] <1. for smaller plots, narrow plots, etc.
.Ve
.IP "radius  \- float" 4
.IX Item "radius  - float"
.Vb 2
\&      radius of the dot to be plotted. Defaults to 
\&      some fraction of the screen width.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
xtpen, Graph, Histogram
.SH "BUGS"
.IX Header "BUGS"
.Vb 1
\& Needs pclip, you must preprocess for unusual clip needs.
.Ve
.SH "COMPILE LEVEL"
.IX Header "COMPILE LEVEL"
.Vb 1
\& DISTR
.Ve
.SH "CATEGORY"
.IX Header "CATEGORY"
\&\fBsep_graphics\fR
